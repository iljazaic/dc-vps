//generated by claude sonnet 4.5
//can be insane


const express = require('express');
const crypto = require('crypto');

const app = express();

// IMPORTANT: Use raw body for webhook signature verification
app.use('/webhooks/nets', express.raw({ type: 'application/json' }));
app.use(express.json()); // For other routes

// Your Nets webhook secret key (get this from Nets dashboard)
const WEBHOOK_SECRET = process.env.NETS_WEBHOOK_SECRET;

// Verify webhook signature
function verifyWebhookSignature(payload, signature) {
    const hmac = crypto.createHmac('sha256', WEBHOOK_SECRET);
    const digest = hmac.update(payload).digest('hex');
    return crypto.timingSafeEqual(
        Buffer.from(signature),
        Buffer.from(digest)
    );
}

// Webhook endpoint
app.post('/webhooks/nets', async (req, res) => {
    try {
        // Get signature from header
        const signature = req.headers['authorization']?.replace('Bearer ', '');
        
        if (!signature) {
            console.error('No signature provided');
            return res.status(401).send('Unauthorized');
        }

        // Verify signature with raw body
        const rawBody = req.body.toString('utf8');
        if (!verifyWebhookSignature(rawBody, signature)) {
            console.error('Invalid signature');
            return res.status(401).send('Invalid signature');
        }

        // Parse the webhook payload
        const event = JSON.parse(rawBody);
        
        console.log('Received webhook event:', event.event);

        // Handle different event types
        switch (event.event) {
            case 'payment.subscription.created':
                await handleSubscriptionCreated(event.data);
                break;

            case 'payment.subscription.charged':
                await handleSubscriptionCharged(event.data);
                break;

            case 'payment.subscription.charge.failed':
                await handleSubscriptionChargeFailed(event.data);
                break;

            case 'payment.subscription.cancelled':
                await handleSubscriptionCancelled(event.data);
                break;

            case 'payment.checkout.completed':
                await handleCheckoutCompleted(event.data);
                break;

            default:
                console.log('Unhandled event type:', event.event);
        }

        // Always respond with 200 to acknowledge receipt
        res.status(200).json({ received: true });

    } catch (error) {
        console.error('Webhook error:', error);
        res.status(500).send('Webhook handler error');
    }
});

// Event handlers
async function handleSubscriptionCreated(data) {
    console.log('Subscription created:', data);
    
    const { subscriptionId, paymentId, consumer } = data;
    
    // Store subscription in your database
    await db.subscriptions.create({
        subscriptionId,
        paymentId,
        email: consumer.email,
        status: 'active',
        createdAt: new Date()
    });

    // Send welcome email
    await sendEmail(consumer.email, 'subscription_welcome', {
        subscriptionId
    });
}

async function handleSubscriptionCharged(data) {
    console.log('Subscription charged:', data);
    
    const { subscriptionId, chargeId, amount } = data;
    
    // Update subscription last charged date
    await db.subscriptions.update(subscriptionId, {
        lastChargedAt: new Date(),
        lastChargeAmount: amount,
        status: 'active'
    });

    // Create invoice/receipt
    await createInvoice({
        subscriptionId,
        chargeId,
        amount,
        date: new Date()
    });

    // Send payment confirmation email
    const subscription = await db.subscriptions.findById(subscriptionId);
    await sendEmail(subscription.email, 'payment_success', {
        amount,
        chargeId
    });
}

async function handleSubscriptionChargeFailed(data) {
    console.log('Subscription charge failed:', data);
    
    const { subscriptionId, reason } = data;
    
    // Update subscription status
    await db.subscriptions.update(subscriptionId, {
        status: 'payment_failed',
        failureReason: reason,
        lastFailedAt: new Date()
    });

    // Get subscription details
    const subscription = await db.subscriptions.findById(subscriptionId);

    // Send payment failed email
    await sendEmail(subscription.email, 'payment_failed', {
        subscriptionId,
        reason,
        updatePaymentUrl: `https://yoursite.com/update-payment/${subscriptionId}`
    });

    // Implement retry logic or grace period
    // After X failed attempts, suspend service
    const failedAttempts = await db.getFailedAttempts(subscriptionId);
    if (failedAttempts >= 3) {
        await suspendService(subscriptionId);
    }
}

async function handleSubscriptionCancelled(data) {
    console.log('Subscription cancelled:', data);
    
    const { subscriptionId, cancelledBy } = data;
    
    // Update subscription status
    await db.subscriptions.update(subscriptionId, {
        status: 'cancelled',
        cancelledAt: new Date(),
        cancelledBy // 'consumer' or 'merchant'
    });

    // Cancel any scheduled tasks
    await cancelScheduledTasks(subscriptionId);

    // Send cancellation confirmation
    const subscription = await db.subscriptions.findById(subscriptionId);
    await sendEmail(subscription.email, 'subscription_cancelled', {
        subscriptionId,
        endDate: subscription.currentPeriodEnd
    });
}

async function handleCheckoutCompleted(data) {
    console.log('Checkout completed:', data);
    
    // Initial checkout completion
    // The subscription.created event will handle the rest
}

// Helper functions (implement these based on your setup)
async function sendEmail(to, template, data) {
    // Your email sending logic
    console.log(`Sending ${template} email to ${to}`);
}

async function createInvoice(invoiceData) {
    // Your invoice creation logic
    console.log('Creating invoice:', invoiceData);
}

async function suspendService(subscriptionId) {
    // Your service suspension logic
    console.log('Suspending service for:', subscriptionId);
}

async function cancelScheduledTasks(subscriptionId) {
    // Cancel any scheduled tasks for this subscription
    console.log('Cancelling tasks for:', subscriptionId);
}

// Mock database object (replace with your actual DB)
const db = {
    subscriptions: {
        create: async (data) => console.log('DB: Creating subscription', data),
        update: async (id, data) => console.log('DB: Updating subscription', id, data),
        findById: async (id) => ({ 
            id, 
            email: 'user@example.com',
            currentPeriodEnd: new Date()
        })
    },
    getFailedAttempts: async (id) => 1
};

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
    console.log(`Webhook server listening on port ${PORT}`);
});